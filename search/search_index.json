{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About","text":"<p><code>fair-workflow</code> is a Python library.</p> <p>A package to describe workflow using semantic technologies.</p>"},{"location":"#i-how-it-works","title":"\u2139\ufe0f How it works","text":"<p>You can use it with a CLI, or as an object in a python script.</p> <p>Report issues</p> <p>Feel free to create issues on GitHub, if you are facing problems, have a question, or would like to see a feature implemented. Pull requests are welcome!</p>"},{"location":"#projects-using-fair-workflow","title":"\ud83d\uddc3\ufe0f Projects using fair-workflow","text":"<p>Here are some projects using <code>fair-workflow</code>:</p> <ul> <li>TODO</li> </ul>"},{"location":"#credits","title":"\ud83e\udd1d Credits","text":"<p>Library built with MaastrichtU-IDS/cookiecutter-python-package.</p>"},{"location":"development/","title":"Development","text":""},{"location":"development/#install-for-development","title":"\ud83d\udce5 Install for development","text":"<p>Clone the repository and go in the project folder:</p> <pre><code>git clone https://github.com/MaastrichtU-IDS/fair-workflow\ncd fair-workflow\n</code></pre> <p>To install the project for development you can either use <code>venv</code> to create a virtual environment yourself, or use <code>hatch</code> to automatically handle virtual environments for you.</p> <p>=== \u201cvenv\u201d</p> <pre><code>Create the virtual environment in the project folder :\n\n```bash\npython3 -m venv .venv\n```\n\nActivate the virtual environment:\n\n```bash\nsource .venv/bin/activate\n```\n\nInstall all dependencies required for development:\n\n```bash\npip install -e \".[dev,doc,test]\"\n```\n\nInstall `pre-commit` to enable automated formatting and linting of the code at each commit:\n\n```bash\npre-commit install\n```\n</code></pre> <p>=== \u201chatch\u201d</p> <pre><code>Install [Hatch](https://hatch.pypa.io), this will automatically handle virtual environments and make sure all dependencies are installed when you run a script in the project:\n\n```bash\npip install hatch\n```\n\n??? note \"Optionally you can improve `hatch` terminal completion\"\n\n    See the [official documentation](https://hatch.pypa.io/latest/cli/about/#tab-completion) for more details. For ZSH you can run these commands:\n\n    ```bash\n    _HATCH_COMPLETE=zsh_source hatch &gt; ~/.hatch-complete.zsh\n    echo \". ~/.hatch-complete.zsh\" &gt;&gt; ~/.zshrc\n    ```\n</code></pre>"},{"location":"development/#development-workflow","title":"\ud83e\uddd1\u200d\ud83d\udcbb Development workflow","text":"<p>=== \u201cvenv\u201d</p> <pre><code>Try to sign a nanopublication with the code defined in `scripts/dev.py` to test your changes:\n\n```bash\n./scripts/dev.sh\n```\n\nThe code will be automatically formatted when you commit your changes using `pre-commit`. But you can also run the script to format the code yourself:\n\n```bash\n./scripts/format.sh\n```\n\nCheck the code for errors, and if it is in accordance with the PEP8 style guide, by running `flake8` and `mypy`:\n\n```bash\n./scripts/lint.sh\n```\n</code></pre> <p>=== \u201chatch\u201d</p> <pre><code>Try to sign a nanopublication with the code defined in `scripts/dev.py` to test your changes:\n\n```bash\nhatch run dev\n```\n\nThe code will be automatically formatted when you commit your changes using `pre-commit`. But you can also run the script to format the code yourself:\n\n```bash\nhatch run format\n```\n\nCheck the code for errors, and if it is in accordance with the PEP8 style guide, by running `flake8` and `mypy`:\n\n```bash\nhatch run lint\n```\n</code></pre>"},{"location":"development/#run-the-tests","title":"\u2705 Run the tests","text":"<p>Tests are automatically run by a GitHub Actions workflow when new code is pushed to the GitHub repository.</p> <p>The tests use the <code>nanopub-java</code> tool for validating the signing process implemented in python produces similar nanopublications. This is automatically installed by the library, just make sure <code>java</code> is available where you run the tests.</p> <p>=== \u201cvenv\u201d</p> <pre><code>Run the tests locally:\n\n```bash\n./scripts/test.sh\n```\n\nYou can also run only a specific test:\n\n```bash\n./scripts/test.sh tests/cli.py::test_cli\n```\n</code></pre> <p>=== \u201chatch\u201d</p> <pre><code>Run the tests locally:\n\n```bash\nhatch run test\n```\n\nYou can also run only a specific test:\n\n```bash\nhatch run test tests/cli.py::test_cli\n```\n</code></pre>"},{"location":"development/#generate-docs","title":"\ud83d\udcd6 Generate docs","text":"<p>The documentation (this website) is automatically generated from the markdown files in the <code>docs</code> folder and python docstring comments, and published by a GitHub Actions workflow.</p> <p>Serve the docs on http://localhost:8008</p> <p>=== \u201cvenv\u201d</p> <pre><code>```bash\n./scripts/docs.sh\n```\n</code></pre> <p>=== \u201chatch\u201d</p> <pre><code>```bash\nhatch run docs\n```\n</code></pre>"},{"location":"development/#publish-a-new-release","title":"\ud83c\udff7\ufe0f Publish a new release","text":"<ol> <li>Increment the <code>__version__</code> in <code>fair_workflow/__init__.py</code></li> <li>Push to GitHub</li> <li>Create a new release on GitHub</li> <li>A GitHub Action workflow will automatically publish the new version to PyPI</li> </ol>"},{"location":"fair_workflow/","title":"Api","text":""},{"location":"fair_workflow/#fair_workflow.fair_workflow.extract_functions","title":"<code>extract_functions(source_code)</code>","text":"<p>Extract functions used in a function</p> Source code in <code>fair_workflow/fair_workflow.py</code> <pre><code>def extract_functions(source_code):\n\"\"\"Extract functions used in a function\"\"\"\nfunc_meta = {\n\"args\": [],\n\"returns\": [],\n\"func_calls\": [],\n}\nparsed_code = ast.parse(source_code)\nfor node in ast.walk(parsed_code):\nif isinstance(node, ast.FunctionDef):\nfunc_meta[\"name\"] = node.name\nfunc_meta[\"args\"] = ([arg.arg for arg in node.args.args],)\nfunc_meta[\"returns\"] = [child.value.id for child in ast.walk(node) if isinstance(child, ast.Return)]\nif isinstance(node, ast.Assign):\n# Extract args\nargs = {}\nif isinstance(node.value, ast.Call):\nfor arg in node.value.keywords:\nif isinstance(arg.value, ast.Name):\nargs[arg.arg] = arg.value.id\nif isinstance(arg.value, ast.Constant):\nargs[arg.arg] = ast.literal_eval(arg.value)\n# Extract returns\nfor child in ast.iter_child_nodes(node):\nif isinstance(child, ast.Name):\nassigned_vars = [child.id]\nif isinstance(child, ast.Tuple):\nassigned_vars = []\n# for tuple_value in child.dims:\n#        assigned_vars.append(tuple_value.id)\nif isinstance(child, ast.Call):\nfunction_name = child.func.id\n# import importlib\n# module = importlib.import_module(module_name)\n# class_ = getattr(module, class_name)\n# import sys\n# print(dir(sys.modules[__name__]))\n# current_module = globals()[\"__name__\"]\n# print(globals()[\"__name__\"])\n# print(inspect.getsource(function_name))\n# print(\"CHILDISH\")\n# print(child)\n# for childish in ast.iter_child_nodes(child):\n#     if isinstance(childish, ast.Constant):\n#         print(ast.literal_eval(childish))\n#     elif isinstance(childish, ast.Name):\n#         print(childish.id)\n#     elif isinstance(childish, ast.keyword):\n#         for arg_child in ast.iter_child_nodes(childish):\n#             print(arg_child)\n#     else:\n#         print(childish)\n# input_params = [arg.id for arg in node.args]\n# for arg in child.args:\n#     print(\"ARGS\")\n#     print(arg)\n#     if isinstance(arg, ast.Constant):\n#         print(ast.literal_eval(arg))\n#     else:\n#         print(arg.id)\nfunc_meta[\"func_calls\"].append({\"name\": function_name, \"args\": args, \"returns\": assigned_vars})\nreturn func_meta\n</code></pre>"},{"location":"fair_workflow/#fair_workflow.fair_workflow.fair_workflow","title":"<code>fair_workflow(label)</code>","text":"<p>A decorator to indicate a function is a fair workflow</p> Source code in <code>fair_workflow/fair_workflow.py</code> <pre><code>def fair_workflow(\nlabel: str,\n):\n\"\"\"A decorator to indicate a function is a fair workflow\"\"\"\ndef decorator(func):\n@functools.wraps(func)\ndef wrapper(*args, **qwargs):\nreturn func(*args, **qwargs)\nfuncs = extract_functions(inspect.getsource(func))\ng = generate_rdf_triples(funcs)\nwrapper._fair_workflow = g\nwrapper._fair_workflow_visualization = generate_visualization(g)\nwrapper._fair_workflow_cwl = generate_nexflow(g)\nreturn wrapper\nreturn decorator\n</code></pre>"},{"location":"fair_workflow/#fair_workflow.fair_workflow.generate_nexflow","title":"<code>generate_nexflow(g)</code>","text":"<p>Generate Nextflow workflow from RDFLib Graph</p> Source code in <code>fair_workflow/fair_workflow.py</code> <pre><code>def generate_nexflow(g):\n\"\"\"Generate Nextflow workflow from RDFLib Graph\"\"\"\nsteps = {}\nvar_dict = {}\nfor s, p, o in g.triples((None, RDF[\"value\"], None)):\nvar = str(s).split(\"/\")[-1]\nval = str(o).split(\"/\")[-1]\nvar_dict[var] = val\nprint(var_dict)\nfor s, p, o in g.triples((None, PPLAN[\"isOutputVarOf\"], None)):\nstep = str(s).split(\"/\")[-1]\nvar = str(o).split(\"/\")[-1]\nif step not in steps:\nsteps[step] = []\nsteps[step].append(var)\ndeps = {}\nfor s, p, o in g.triples((None, DUL[\"precedes\"], None)):\nstep1 = str(s).split(\"/\")[-1]\nstep2 = str(o).split(\"/\")[-1]\nif step2 not in deps:\ndeps[step2] = []\ndeps[step2].append(step1)\n# generate the Netflow description\nnextflow_desc = \"\"\nfor step in steps:\nnextflow_desc += f\"process {step} {{\\n\"\nnextflow_desc += \"  input:\\n\"\nfor var in steps[step]:\nnextflow_desc += f\"    file {var} from {var_dict[var]} \\n\"\nnextflow_desc += \"  output:\\n\"\nnextflow_desc += f\"    {var}: File\\n\"\nnextflow_desc += \"  script: ...\\n\"\nnextflow_desc += \"}}\\n\"\nfor step1 in deps:\nfor step2 in deps[step1]:\nnextflow_desc += f\"{step1} -&gt; {step2}\\n\"\nprint(nextflow_desc)\nreturn nextflow_desc\n</code></pre>"},{"location":"fair_workflow/#fair_workflow.fair_workflow.generate_rdf_triples","title":"<code>generate_rdf_triples(func_meta, namespace=NP)</code>","text":"<p>Generate RDF from the extracted functions infos</p> Source code in <code>fair_workflow/fair_workflow.py</code> <pre><code>def generate_rdf_triples(func_meta, namespace=NP):\n\"\"\"Generate RDF from the extracted functions infos\"\"\"\ng = Graph()\ng.bind(\"pplan\", PPLAN)\ng.bind(\"np\", NP)\ng.bind(\"pwo\", PWO)\ng.bind(\"dul\", DUL)\ng.add((namespace[func_meta[\"name\"]], RDF.type, PPLAN.Plan))\ng.add((namespace[func_meta[\"name\"]], RDFS.label, Literal(func_meta[\"name\"])))\ntry:\nrepo = Repo(\".\")\ngit_url = repo.remotes.origin.url\nexcept:\ngit_url = input(\"No URL to a remote git repository found, provide it please: \")\ng.add((namespace[func_meta[\"name\"]], DUL.realizes, URIRef(git_url)))\nprecedent_step = None\nfor i, data in enumerate(func_meta[\"func_calls\"]):\nfunc_uri = namespace[data[\"name\"]]\nif i == 0:\ng.add((namespace[func_meta[\"name\"]], PPLAN.hasFirstStep, func_uri))\nif precedent_step:\ng.add((precedent_step, DUL.precedes, func_uri))\ng.add((func_uri, RDF.type, PPLAN.Step))\ninput_args = data[\"args\"]\nif input_args:\nfor i, arg in enumerate(input_args.items()):\nname = arg[0]\nvalue = arg[1]\narg_uri = func_uri + \"_\" + name\ng.add((arg_uri, RDF.type, PPLAN.Variable))\ng.add((func_uri, PPLAN.hasInputVar, arg_uri))\ng.add((arg_uri, RDF.value, Literal(value)))\ng.add((arg_uri, RDFS.label, Literal(name)))\nassigned_vars = data[\"returns\"]\nif assigned_vars:\nfor i, var in enumerate(assigned_vars):\nvar_uri = func_uri + \"_\" + var\ng.add((var_uri, rdflib.RDF.type, PPLAN.Variable))\ng.add((func_uri, PPLAN.isOutputVarOf, var_uri))\ng.add((var_uri, rdflib.RDF.value, Literal(var)))\nprecedent_step = func_uri\nreturn g\n</code></pre>"},{"location":"fair_workflow/#fair_workflow.fair_workflow.generate_visualization","title":"<code>generate_visualization(g)</code>","text":"<p>Generate networkx visualization from RDFLib Graph</p> Source code in <code>fair_workflow/fair_workflow.py</code> <pre><code>def generate_visualization(g):\n\"\"\"Generate networkx visualization from RDFLib Graph\"\"\"\ndg = nx.DiGraph()\nfor subject, predicate, obj in g:\nsubject = str(subject).replace(\"http://purl.org/nanopub/temp/np/\", \"\")\n# predicate = str(predicate).replace(\"http://purl.org/nanopub/temp/np/\", \"\")\nobj = str(obj).replace(\"http://purl.org/nanopub/temp/np/\", \"\")\nif (\nstr(predicate) == \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"\nand str(obj) == \"http://purl.org/net/p-plan#Step\"\n):\n# step_node = pydot.Node(subject, shape=\"box\")\n# graph.add_node(step_node)\ndg.add_node(subject, size=100)\n# nx.draw_networkx_nodes(G, pos, node_size=600, node_color='w', alpha=0.4, node_shape='d')\nif (\nstr(predicate) == \"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"\nand str(obj) == \"http://purl.org/net/p-plan#Variable\"\n):\ndg.add_node(subject, size=1)\nelif str(predicate) == \"http://purl.org/net/p-plan#hasInputVar\":\n# input_var_node = pydot.Node(object, shape=\"ellipse\")\n# graph.add_node(input_var_node)\ndg.add_edge(subject, obj)\nelif str(predicate) == \"http://purl.org/net/p-plan#isOutputVarOf\":\n# output_var_node = pydot.Node(object, shape=\"ellipse\")\n# graph.add_node(output_var_node)\n# graph.add_edge(pydot.Edge(subject, output_var_node))\ndg.add_edge(subject, obj)\n# Plot Networkx instance of RDF Graph\npos = nx.spring_layout(dg)\nnx.draw(dg, pos, node_color=\"skyblue\", edge_color=\"gray\", with_labels=True)\n# plt.show()\nreturn plt\n</code></pre>"},{"location":"usage/","title":"Usage","text":"<p>This page explains how to create a FAIR metrics test API with <code>fair-workflow</code>.</p>"},{"location":"usage/#install-the-package","title":"\ud83d\udce5 Install the package","text":"<p>Install the package from PyPI:</p> <pre><code>pip install fair-workflow\n</code></pre>"},{"location":"usage/#define-the-api","title":"\ud83d\udcdd Define the API","text":"<p>Create a <code>main.py</code> file to declare the API, you can provide a different folder than <code>metrics</code> here, the folder path is relative to where you start the API (the root of the repository):</p> main.py<pre><code>from fair_workflow import Api\napi = API()\nprint(api.get_hello_world())\n</code></pre>"}]}